---
title: iso 7层模型-数据链路层-交换机
date: 2025-12-22
category:
  - web
  - 计算机网络
---

# 网络层主要是为了解决很多计算机互联的问题，假如都在二层网的话，会有很多问题。

## 我们已经拥有的
根据上两层的结构，我们已经拥有了一种在两个计算机之间传输数据的办法。

不过，这种办法有几个问题：
1. 很难让多台计算机互联
2. 协议逻辑复杂

为了解决这些问题，我们需要引入新的层次东西——交换机和路由器

## 交换机
交换机就是一个专门用来连接多台计算机的设备，它工作在数据链路层。

交换机的工作原理是：
1. 交换机有多个端口，每个端口可以连接一台计算机
2. 当一台计算机发送数据包时，交换机会根据数据包的目标MAC地址，将数据包转发到对应的端口

这样，交换机就可以实现多台计算机之间的通信，而对于每次通信来讲，信道都是独占的，解决了冲突的问题。

### mac映射表
交换机为了知道每个MAC地址对应哪个端口，会维护一个MAC映射表，当交换机收到数据包时，会查看MAC映射表，找到对应的端口进行转发。

- 如果表上没有对应的MAC地址呢？

交换机会将数据包广播到所有端口，等待目标计算机回应，然后更新MAC映射表。

(注意这里的学习策略是基于源MAC地址的，也就是说每次收到数据包时，都会记录下源MAC地址和对应的端口，也就是说，如果当前端口连接的计算机不回复的话，交换机是不会知道这个MAC地址的)


## 演示（ Mac表维护）

<div class="container">
  <div class="controls">
    <button @click="play" :disabled="isPlaying">播放 (Play)</button>
    <button @click="pause" :disabled="!isPlaying">暂停 (Pause)</button>
    <button @click="nextFrame" :disabled="isPlaying">下一帧 (Next Frame)</button>
    <div class="packet-tool">
      从 
      <select v-model="packetSource">
        <option v-for="pc in pcs" :key="pc.id" :value="pc.id">{{ pc.data.label }}</option>
      </select>
      发给
      <select v-model="packetDest">
        <option v-for="pc in pcs" :key="pc.id" :value="pc.id">{{ pc.data.label }}</option>
      </select>
      <button @click="sendCustomPacket" :disabled="isPlaying || packetSource === packetDest">发送数据包</button>
    </div>
    <span class="status">状态: {{ isPlaying ? '运行中' : '暂停' }}</span>
  </div>
  <div class="main-content">
    <div id="mountNode" ref="graphContainer"></div>
    <div class="side-panel">
      <div class="mac-table-box">
        <div class="panel-header">MAC 映射表 (Switch-1)</div>
        <div class="panel-content">
          <table>
            <thead>
              <tr>
                <th>MAC 地址</th>
                <th>端口 (Node ID)</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="(port, mac) in switchMacTable" :key="mac">
                <td>{{ mac }}</td>
                <td>{{ port }}</td>
              </tr>
              <tr v-if="Object.keys(switchMacTable).length === 0">
                <td colspan="2" style="text-align: center; color: #888;">暂无记录</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="log-box">
        <div class="panel-header">运行日志 (Logs)</div>
        <div class="log-content" ref="logContent">
          <div v-for="(log, index) in logs" :key="index" class="log-item">
            <span class="log-time">[{{ log.time }}]</span> {{ log.message }}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { Graph } from '@antv/g6';

// --- 数据结构定义 ---

// 网络包定义
interface Packet {
  id: string;
  source: string;
  destination: string;
  srcMac: string;
  dstMac: string;
  payload: string;
  color: string; // 颜色字段
  lastNodeId?: string; // 用于追踪来源端口
}

// 随机颜色生成
const getRandomColor = () => {
  const colors = [
    '#F5222D', '#FAAD14', '#13C2C2', '#52C41A', '#1890FF', '#722ED1', '#EB2F96',
    '#A0D911', '#FA541C', '#2F54EB', '#FA8C16', '#13A8A8', '#FADB14', '#FF4D4F'
  ];
  return colors[Math.floor(Math.random() * colors.length)];
};

// 节点数据扩展
interface NodeData {
  id: string;
  data: {
    type: 'pc' | 'router' | 'switch'; // 设备类型
    mac?: string; // PC 的 MAC 地址
    macTable?: Record<string, string>; // 交换机的 MAC 映射表 (MAC -> NodeID)
    packets: Packet[]; // 节点拥有的包列表
    label?: string;
    [key: string]: any; // 其他属性
  };
  style?: {
    fill?: string;
    [key: string]: any;
  }
}

// 边数据
interface EdgeData {
  source: string;
  target: string;
  [key: string]: any;
}

// --- 状态管理 ---

// SVG 图标定义
const routerSvg = `<svg t="1766405043637" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6820" width="200" height="200"><path d="M988.416 821.216l1.504-0.576-101.504-267.328A64.32 64.32 0 0 0 828.608 512h-20.608V112a32 32 0 1 0-64 0V512H544V112a32 32 0 1 0-64 0V512H272V112a32 32 0 0 0-64 0V512h-12.608a64.32 64.32 0 0 0-59.84 41.312l-101.472 267.328 1.504 0.576c-2.112 8.64-3.584 17.504-3.584 26.784C32 909.76 82.24 960 144 960h736c61.76 0 112-50.24 112-112 0-9.28-1.472-18.144-3.584-26.784zM195.392 576h633.184l61.12 160.992c-3.232-0.288-6.368-0.992-9.696-0.992h-736c-3.328 0-6.464 0.704-9.696 0.992L195.392 576zM880 896h-736c-26.464 0-48-21.536-48-48S117.536 800 144 800h736c26.464 0 48 21.536 48 48s-21.536 48-48 48z" p-id="6821"></path></svg>`;
const switchSvg = `<svg t="1766405076812" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7943" width="200" height="200"><path d="M884.363636 325.818182a46.545455 46.545455 0 0 1 46.545455 46.545454v279.272728a46.545455 46.545455 0 0 1-46.545455 46.545454H139.636364a46.545455 46.545455 0 0 1-46.545455-46.545454V372.363636a46.545455 46.545455 0 0 1 46.545455-46.545454h744.727272z m-23.272727 46.545454H162.909091a23.272727 23.272727 0 0 0-23.272727 23.272728v232.727272a23.272727 23.272727 0 0 0 23.272727 23.272728h698.181818a23.272727 23.272727 0 0 0 23.272727-23.272728V395.636364a23.272727 23.272727 0 0 0-23.272727-23.272728z m-372.363636 186.181819a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m93.090909 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m93.090909 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m93.090909 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m-535.272727-139.636364a23.272727 23.272727 0 0 1 23.272727 23.272727v139.636364a23.272727 23.272727 0 0 1-46.545455 0v-139.636364a23.272727 23.272727 0 0 1 23.272728-23.272727z m93.090909 0a23.272727 23.272727 0 0 1 23.272727 23.272727v139.636364a23.272727 23.272727 0 0 1-46.545454 0v-139.636364a23.272727 23.272727 0 0 1 23.272727-23.272727z m162.909091 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m93.090909 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m93.090909 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z m93.090909 0a23.272727 23.272727 0 1 1 0 46.545454 23.272727 23.272727 0 0 1 0-46.545454z" fill="#000000" p-id="7944"></path></svg>`;
const pcSvg = `<svg t="1766405115229" class="icon" viewBox="0 0 1028 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9294" width="200" height="200"><path d="M581.12 753.28v137.6h206.72a34.56 34.56 0 1 1 0 69.12H305.28a34.56 34.56 0 1 1 0-69.12H512v-137.6H201.6A137.6 137.6 0 0 1 64 615.68V201.6A137.6 137.6 0 0 1 201.6 64h689.28a137.6 137.6 0 0 1 137.6 137.6v414.08a137.6 137.6 0 0 1-137.6 137.6zM201.6 133.12a69.76 69.76 0 0 0-68.48 68.48v414.08a69.76 69.76 0 0 0 69.12 69.12h688.64A69.76 69.76 0 0 0 960 615.68V201.6a69.76 69.76 0 0 0-69.12-69.12z" p-id="9295"></path></svg>`;
const envelopeSvg = `<svg t="1766406414644" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10398" width="200" height="200"><path d="M938.666667 898.517333H85.333333c-47.061333 0-85.333333-38.272-85.333333-85.333333V218.666667c0-47.061333 38.272-85.333333 85.333333-85.333334h853.333334c47.061333 0 85.333333 38.272 85.333333 85.333334v594.517333c0 47.018667-38.272 85.333333-85.333333 85.333333z m0-85.333333v42.666667-42.666667zM85.333333 218.666667v594.517333h853.205334L938.666667 218.666667H85.333333z" fill="#757575" p-id="10399"></path><path d="M916.821333 158.464a42.794667 42.794667 0 0 1 0 60.330667l-373.333333 373.376a42.794667 42.794667 0 0 1-60.330667 0 42.837333 42.837333 0 0 1 0-60.373334l373.333334-373.333333a42.794667 42.794667 0 0 1 60.330666 0z" fill="#757575" p-id="10400"></path><path d="M107.178667 158.464a42.794667 42.794667 0 0 0 0 60.330667l373.333333 373.376a42.794667 42.794667 0 0 0 60.330667 0 42.922667 42.922667 0 0 0 0-60.373334l-373.333334-373.333333a42.794667 42.794667 0 0 0-60.330666 0z" fill="#757575" p-id="10401"></path></svg>`;

const svgToDataUrl = (svg: string) => {
  return `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svg)))}`;
};

const graphContainer = ref<HTMLElement | null>(null);
const logContent = ref<HTMLElement | null>(null);
let graph: Graph | null = null;
const isPlaying = ref(false);
let timer: number | null = null;

const packetSource = ref('pc-1');
const packetDest = ref('pc-2');

// 初始数据 (模拟拓扑)
const rawData = ref<{ nodes: NodeData[], edges: EdgeData[] }>({
  nodes: [
    { id: 'pc-1', data: { type: 'pc', label: 'PC-1 (AA)', mac: 'AA', packets: [] }, style: { fill: '#61DDAA' } },
    { id: 'pc-2', data: { type: 'pc', label: 'PC-2 (BB)', mac: 'BB', packets: [] }, style: { fill: '#61DDAA' } },
    { id: 'pc-3', data: { type: 'pc', label: 'PC-3 (CC)', mac: 'CC', packets: [] }, style: { fill: '#61DDAA' } },
    { id: 'pc-4', data: { type: 'pc', label: 'PC-4 (DD)', mac: 'DD', packets: [] }, style: { fill: '#61DDAA' } },
    { id: 'switch-1', data: { type: 'switch', label: 'Switch-1', macTable: {}, packets: [] }, style: { fill: '#F6BD16' } },
  ],
  edges: [
    { source: 'pc-1', target: 'switch-1' },
    { source: 'pc-2', target: 'switch-1' },
    { source: 'pc-3', target: 'switch-1' },
    { source: 'pc-4', target: 'switch-1' },
  ],
});

// 计算属性
import { computed } from 'vue';
const pcs = computed(() => rawData.value.nodes.filter(n => n.data.type === 'pc'));
const switchMacTable = computed(() => {
  const sw = rawData.value.nodes.find(n => n.id === 'switch-1');
  return sw?.data.macTable || {};
});

// --- 日志管理 ---

const logs = ref<{ time: string; message: string }[]>([]);

const addLog = (message: string) => {
  const now = new Date();
  const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
  logs.value.push({ time: timeStr, message });
  // 自动滚动到底部
  setTimeout(() => {
    if (logContent.value) {
      logContent.value.scrollTop = logContent.value.scrollHeight;
    }
  }, 0);
};

// --- 核心逻辑 ---

const getNeighbors = (nodeId: string) => {
  return rawData.value.edges
    .filter(e => e.source === nodeId || e.target === nodeId)
    .map(e => e.source === nodeId ? e.target : e.source);
};

const sendCustomPacket = () => {
  const srcNode = rawData.value.nodes.find(n => n.id === packetSource.value);
  const dstNode = rawData.value.nodes.find(n => n.id === packetDest.value);
  
  if (srcNode && dstNode) {
    srcNode.data.packets.push({
      id: Math.random().toString(36).substr(2, 9),
      source: srcNode.id,
      destination: dstNode.id,
      srcMac: srcNode.data.mac!,
      dstMac: dstNode.data.mac!,
      payload: `Msg from ${srcNode.data.label}`,
      color: getRandomColor(),
    });
    addLog(`${srcNode.data.label} 准备发送数据包到 ${dstNode.data.label} (目标MAC: ${dstNode.data.mac})`);
    graph?.render();
  }
};

// 1. 规则执行函数 (核心)
// 每次 tick 都会调用这个函数
const runSimulationRules = () => {
  if (!graph) return;
  
  addLog("--- 模拟步进 (Tick) ---");
  
  // 临时存储下一时刻的包分布，避免同一 tick 内包无限传递
  const nextPacketsMap = new Map<string, Packet[]>();

  rawData.value.nodes.forEach(node => {
    const packets = [...node.data.packets];
    node.data.packets = []; // 清空当前节点的包，准备移动

    packets.forEach(packet => {
      if (node.data.type === 'pc') {
        if (packet.dstMac === node.data.mac) {
          addLog(`[收包] ${node.data.label} 成功接收到发给自己的包: "${packet.payload}"`);
        } else if (packet.srcMac === node.data.mac && !packet.lastNodeId) {
          // PC 发送初始包
          const neighbors = getNeighbors(node.id);
          neighbors.forEach(neighborId => {
            if (!nextPacketsMap.has(neighborId)) nextPacketsMap.set(neighborId, []);
            nextPacketsMap.get(neighborId)!.push({ ...packet, lastNodeId: node.id });
            addLog(`[发包] ${node.data.label} 将包发送至交换机 ${neighborId}`);
          });
        } else {
          addLog(`[丢弃] ${node.data.label} 收到非本机的包 (目标MAC: ${packet.dstMac})，丢弃`);
        }
      } else if (node.data.type === 'switch') {
        // 1. 学习 (Learning)
        if (!node.data.macTable) node.data.macTable = {};
        
        const isNewEntry = !node.data.macTable[packet.srcMac];
        const oldPort = node.data.macTable[packet.srcMac];
        
        node.data.macTable[packet.srcMac] = packet.lastNodeId!;
        
        if (isNewEntry) {
          addLog(`[学习] 交换机 ${node.id} 发现新设备: MAC ${packet.srcMac} 位于端口 ${packet.lastNodeId}`);
        } else if (oldPort !== packet.lastNodeId) {
          addLog(`[更新] 交换机 ${node.id} 发现设备迁移: MAC ${packet.srcMac} 现在位于端口 ${packet.lastNodeId} (原端口: ${oldPort})`);
        } else {
          addLog(`[确认] 交换机 ${node.id} 收到包，确认 MAC ${packet.srcMac} 仍在端口 ${packet.lastNodeId}`);
        }

        // 2. 转发 (Forwarding)
        const targetPort = node.data.macTable[packet.dstMac];
        if (targetPort) {
          // 单播转发
          if (!nextPacketsMap.has(targetPort)) nextPacketsMap.set(targetPort, []);
          nextPacketsMap.get(targetPort)!.push({ ...packet, lastNodeId: node.id });
          addLog(`[转发] 交换机 ${node.id} 查表发现目标 MAC ${packet.dstMac} 在端口 ${targetPort}，执行单播`);
        } else {
          // 广播 (Flooding)
          addLog(`[广播] 交换机 ${node.id} 未发现目标 MAC ${packet.dstMac}，执行全端口广播 (Flooding)`);
          const neighbors = getNeighbors(node.id);
          neighbors.forEach(neighborId => {
            if (neighborId !== packet.lastNodeId) {
              if (!nextPacketsMap.has(neighborId)) nextPacketsMap.set(neighborId, []);
              nextPacketsMap.get(neighborId)!.push({ ...packet, lastNodeId: node.id });
            }
          });
        }
      }
    });
  });

  // 将包放入新位置
  nextPacketsMap.forEach((packets, nodeId) => {
    const node = rawData.value.nodes.find(n => n.id === nodeId);
    if (node) {
      node.data.packets.push(...packets);
    }
  });

  // 更新节点样式以显示是否有包
  rawData.value.nodes.forEach(node => {
    if (node.data.packets.length > 0) {
      node.style = { ...node.style, stroke: '#ff4d4f', lineWidth: 3 };
    } else {
      node.style = { ...node.style, stroke: undefined, lineWidth: 1 };
    }
  });

  graph.setData(rawData.value);
  graph.render();
};

// 2. 单步执行
const nextFrame = () => {
  runSimulationRules();
};

// 3. 播放
const play = () => {
  if (isPlaying.value) return;
  isPlaying.value = true;
  // 每 1000ms 运行一次
  timer = window.setInterval(() => {
    nextFrame();
  }, 1000);
};

// 4. 暂停
const pause = () => {
  isPlaying.value = false;
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
};

// --- 生命周期 ---

onMounted(() => {
  if (graphContainer.value) {
    // 初始化 G6 图实例
    graph = new Graph({
      container: graphContainer.value,
      data: rawData.value,
      node: {
        style: (d: any) => {
          let iconSrc = '';
          if (d.data.type === 'router') iconSrc = svgToDataUrl(routerSvg);
          else if (d.data.type === 'switch') iconSrc = svgToDataUrl(switchSvg);
          else if (d.data.type === 'pc') iconSrc = svgToDataUrl(pcSvg);

          const packets = (d.data.packets as Packet[]) || [];
          const badges = packets.map((packet, index) => ({
            text: '✉',
            fontSize: 20,
            fill: packet.color,
            backgroundFill: 'transparent',
            size: 24,
            x: (index - (packets.length - 1) / 2) * 25,
            y: -35,
          }));

          return {
            size: 40,
            labelText: d.data.label,
            labelPlacement: 'bottom',
            icon: true,
            iconSrc: iconSrc,
            iconWidth: 30,
            iconHeight: 30,
            fill: 'transparent',
            badges: badges,
          };
        },
      },
      edge: {
        style: {
        },
      },
      layout: {
        type: 'force', // 力导向布局，自动分布
        preventOverlap: true,
        linkDistance: 150,
      },
      behaviors: ['drag-canvas', 'zoom-canvas', 'drag-element'], // 允许拖拽和缩放
    });

    graph.render();
  }
});

onUnmounted(() => {
  if (graph) {
    graph.destroy();
  }
  if (timer) {
    clearInterval(timer);
  }
});
</script>

<style scoped>
.container {
  width: 95%;
  margin: 20px auto;
  display: flex;
  flex-direction: column;
  border-radius: 10px;
  border: 1px solid #bfbebe;
  background-color: #f9f9f9;
}

.controls {
  padding: 15px;
  background-color: #fff;
  border-bottom: 1px solid #ddd;
  display: flex;
  gap: 15px;
  align-items: center;
  flex-wrap: wrap;
}

.packet-tool {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: #e6f7ff;
  border-radius: 4px;
  border: 1px solid #91d5ff;
}

.controls button {
  padding: 6px 12px;
  cursor: pointer;
  border: 1px solid #d9d9d9;
  background: #fff;
  border-radius: 4px;
}

.controls button:hover:not(:disabled) {
  color: #40a9ff;
  border-color: #40a9ff;
}

.controls button:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.status {
  margin-left: auto;
  font-weight: bold;
  color: #555;
}

.main-content {
  display: flex;
  height: 600px;
}

#mountNode {
  flex: 2;
  background-color: #fff;
  border-right: 1px solid #eee;
}

.side-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #fff;
}

.panel-header {
  padding: 8px 12px;
  background-color: #fafafa;
  font-size: 13px;
  font-weight: bold;
  color: #333;
  border-bottom: 1px solid #eee;
  border-top: 1px solid #eee;
}

.mac-table-box {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.panel-content {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

th, td {
  border: 1px solid #f0f0f0;
  padding: 8px;
  text-align: left;
}

th {
  background: #fafafa;
}

.log-box {
  flex: 1;
  background-color: #1e1e1e;
  color: #d4d4d4;
  font-family: 'Consolas', 'Courier New', monospace;
  display: flex;
  flex-direction: column;
  max-height: 300px;
}

.log-box .panel-header {
  background-color: #333;
  color: #aaa;
  border-bottom: 1px solid #444;
}

.log-content {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
  font-size: 12px;
  line-height: 1.6;
}

.log-item {
  margin-bottom: 4px;
  word-break: break-all;
}

.log-time {
  color: #569cd6;
  margin-right: 8px;
}
</style>
