---
title: iso 7层模型-物理层和数据链路层
date: 2025-12-13
category:
  - web
  - 计算机网络
---
[下一章：数据链路层](数据链路层.md)
# 根据我的个人理解，这两层主要是为了解决两台计算机之间互相沟通。

## 物理层
从最基础的物理介质开始，传输比特流

因为计算机只能识别0和1，所以物理层负责把0和1转换成电信号、光信号或者无线电波进行传输

有好多内容，我这里就只写我觉得比较重要的吧

- 传输介质：双绞线、光纤、无线电波，反正就是传输0和1的东西，甚至声音都行
- 信号的表示方式：比如用电压的高低来表示0和1，然后无线电波的频率、幅度、相位也可以用来表示0和1

  常见的编码方式包括：
  - NRZ（非归零码）：高电压表示1，低电压表示0。
  - Manchester编码：每个比特周期内电压变化一次，上升沿表示1，下降沿表示0，便于时钟同步。
  - 4B/5B编码：将4位数据编码成5位，便于检测错误。

- 接口和连接器：比如RJ45接口、光纤接口等

物理层只定义了基础的，物理相关的性质，几乎没有和逻辑相关的协议

## 数据链路层
### 为了解决什么问题？
物理层只定义了一些最基础的信息，但是要达成我们的目标（把一串二进制字符传到另一个机器上面），还需要解决一个问题

- 二进制串怎么转换成现实中物理的表达方式？

首先我们要清楚连接两台机器的电线在同一时刻只可能有一种状态，要么高电压，要么低电压。但是我们要传输的二进制串可能是1011001，所以我们必定不能在同一时刻传输多个比特。

为了传输比特串，我们需要把比特串分成一个一个的比特，然后一个一个地传输过去。

我们可以规定两台机器在固定的时间间隔内传输一个比特，比如每隔1毫秒传输一个比特，那么在第1毫秒传输第一个比特，在第2毫秒传输第二个比特，以此类推。

这样就可以把比特串传输过去了。

- 不过现在还有一个问题，两台机器的时间间隔有可能不一致。在没有事先沟通的情况下我们怎么知道对方每隔多少时间传输一个比特呢？

为了解决这个问题，我们可以在传输数据之前，先传输一段特殊的比特串，叫做前导码。

前导码的作用是让接收方自己根据电压变化的间隔来判断时间间隔，这样接收方就可以根据前导码来同步自己的时钟，从而正确地接收数据。

- 但是问题又来了，我们现在靠时间分割字符流，那我们该怎么判断机器A传输的第1毫秒是第一个比特还是第二个比特呢？

我们可以给原来要发送的数据前面加上一个帧开始定界符，告诉接收方“嘿，我要开始传输数据了”，这样接收方就可以根据帧开始定界符来判断数据的开始位置，从而正确地接收数据。
### 如果有三台以上的机器呢？
- 现在假设有三台机器A、B、C连接在同一条物理介质上面，A想给B发送数据，那么C怎么知道数据不是发给它的呢？

我们可以给数据包加上目的MAC地址，告诉接收方“嘿，这个数据包是发给你的”，这样接收方就可以根据目的MAC地址来判断数据包是否是发给自己的，从而正确地接收数据。

- 但是问题又来了，A给B发送数据的时候，B怎么知道数据是从哪里来的呢？

我们可以给数据包加上源MAC地址，告诉接收方“嘿，这个数据包是从哪里来的”，这样接收方就可以根据源MAC地址来判断数据包的来源，从而正确地处理数据。
### 数据传输过程中可能出现错误怎么办？
- 在数据传输过程中，可能会因为各种原因导致数据出错，比如电磁干扰、信号衰减等。那么接收方怎么知道数据有没有出错呢？

我们可以给数据包加上CRC校验码，这个校验码会根据数据包的内容计算出来，接收方收到数据包后也会计算一次CRC校验码，然后和数据包中的CRC校验码进行比较，如果不一致就说明数据出错了。

CRC校验使用多项式除法（如CRC-32），而不是简单的奇偶校验。数据链路层并不解决可靠性的问题，所以如果出现错误了，它只会直接丢弃，而不是请求重发。

### 紧接着还有一些代表数据类型长度之类的细节
- 我们还需要告诉接收方数据部分有多长，这样接收方才能正确地接收数据。

### CSMA/CD
- 当多台机器连接在同一条物理介质上时，可能会出现多台机器同时发送数据，导致数据冲突，接收方收到的数据就会出错。

为了解决这个问题，可以使用CSMA/CD（载波监听多路访问/冲突检测）协议。

每台机器在发送前会先监听总线（线路）是否空闲。如果总线空闲，则开始发送数据；如果总线忙碌（有其他设备在发送），则等待一段随机时间后再次监听，直到总线空闲为止。

如果在发送过程中检测到冲突，所有发送方会立即停止发送，并等待一个随机退避时间后重新尝试发送。

具体的，每台设备在发送数据的同时，会实时监听总线上的信号（即“边发边听”）。如果设备检测到自己发送到总线上的信号和它从总线上“听到”的信号不一致（比如电压、电流、波形等出现异常），就说明有别的设备也在同时发送，发生了冲突。

那么设备会立即停止发送，并发送一串特殊的“冲突信号”通知其他设备发生了冲突。
### 最终，我们规定数据链路层二进制流结构为这样（不是所有的都是这样的，这里举一种常见的状况）：

| 字段名称   | 长度（字节） | 作用说明               |
|------------|--------------|------------------------|
| 前导码     | 7            | 帧开始的标志，同步时钟 |
| 帧开始定界符 | 1          | 标记帧正式开始         |
| 目的MAC地址 | 6           | 目标设备的物理地址     |
| 源MAC地址   | 6           | 发送设备的物理地址     |
| 类型/长度   | 2           | 上层协议类型或数据长度 |
| 数据部分    | 46~1500      | 实际传输的数据         |
| CRC校验     | 4           | 检查数据是否出错       |

举例说明（假设用16进制表示）：

101010...1011  | a5 |  11 22 33 44 55 66  |  AA BB CC DD EE FF  |  08 00  |  ...数据...  |  1A 2B 3C 4D |

[前导码]     [帧开始定界符]    [目的MAC地址]           [源MAC地址]            [类型/长度]     [数据部分]      [CRC校验]

## 演示
<div class="container">
  <div class="controls">
    <div class="control-group">
      <h3>发送端设置</h3>
      <label>选择发送机器: 
        <select v-model="sender">
          <option value="A">机器 A (MAC: {{ machines.A.mac }})</option>
          <option value="B">机器 B (MAC: {{ machines.B.mac }})</option>
          <option value="C">机器 C (MAC: {{ machines.C.mac }})</option>
        </select>
      </label>
      <label>目标 MAC 地址: <input v-model="targetMac" placeholder="例如: CC:CC:CC:CC:CC:CC" /></label>
      <label>数据 (二进制): <input v-model="dataInput" placeholder="例如: 1011001" /></label>
      <button @click="startSending" :disabled="machines[sender].state !== 'IDLE'">发送数据</button>
    </div>
    <div class="control-group">
      <h3>网络状态监控</h3>
      <div v-for="m in machines" :key="m.id" class="machine-status">
        <strong>机器 {{ m.id }}</strong>: 
        <span :class="getStatusClass(m.state)">{{ m.state }}</span>
      </div>
    </div>
  </div>

  <div class="frame-preview-container">
    <h3>当前帧结构预览</h3>
    <div class="frame-preview">
      <div 
        v-for="(field, index) in frameFields" 
        :key="index" 
        class="frame-field"
        :style="{ backgroundColor: field.color }"
        :title="field.desc"
      >
        <div class="field-name">{{ field.name }}</div>
        <div class="field-value">{{ field.value }}</div>
      </div>
    </div>
    <div class="legend">
      <span v-for="(field, index) in frameFields" :key="index" class="legend-item">
        <span class="color-box" :style="{ backgroundColor: field.color }"></span>
        {{ field.desc }}
      </span>
    </div>
  </div>

  <div class="visualization">
    <canvas ref="canvas" width="800" height="300"></canvas>
  </div>

  <div class="logs">
    <h3>系统日志</h3>
    <div class="log-window" ref="logWindow">
      <div v-for="(log, index) in logs" :key="index" class="log-entry">{{ log }}</div>
    </div>
  </div>
</div>

<script setup lang="ts">
import { ref, reactive, onMounted, onUnmounted, computed } from 'vue';

// --- 类型定义 ---
type MachineState = 'IDLE' | 'WAITING_BUS' | 'BACKOFF' | 'SENDING' | 'RECEIVING';
type RxState = 'SEARCHING' | 'READING_HEADER' | 'READING_DATA' | 'READING_CRC';

interface Machine {
  id: string;
  mac: string;
  state: MachineState;
  buffer: number[]; // 待发送的比特流
  bitIndex: number;
  backoffTimer: number;
  currentOutput: number; // 当前输出电平 (1=High, 0=Low)
  
  // 接收相关
  rxBuffer: number[];
  rxState: RxState;
  rxBitCount: number;
  parsedDestMac: string;
  parsedSrcMac: string;
  parsedLength: number;
}

// --- 常量 ---
const PREAMBLE_BYTE = 0xAA; // 10101010
const SFD_BYTE = 0xAB;      // 10101011
const PREAMBLE_LEN = 7;
const MAC_LEN = 6;
const LENGTH_LEN = 2;       // 2 bytes for Length
const CRC_LEN = 4;

// --- 状态 ---
const sender = ref<'A' | 'B' | 'C'>('A');
const targetMac = ref('CC:CC:CC:CC:CC:CC');
const dataInput = ref('1010101');
const logs = ref<string[]>([]);
const logWindow = ref<HTMLDivElement | null>(null);
const canvas = ref<HTMLCanvasElement | null>(null);

const busLevel = ref(1); // 1 = High (Idle), 0 = Low (Active)
const busHistory = ref<number[]>(new Array(100).fill(1));

// 颜色定义
const COLORS = {
  PREAMBLE: '#e0e0e0',
  SFD: '#bdbdbd',
  DEST_MAC: '#90caf9', // Blue 200
  SRC_MAC: '#a5d6a7',  // Green 200
  LENGTH: '#ffcc80',   // Orange 200
  DATA: '#fff59d',     // Yellow 200
  CRC: '#ef9a9a'       // Red 200
};

const frameFields = computed(() => {
  const m = machines[sender.value];
  const dest = targetMac.value || '00:00:00:00:00:00';
  const src = m.mac;
  const dataBits = binStringToBits(dataInput.value);
  
  // Length
  const byteLen = Math.ceil(dataBits.length / 8);
  const lenHex = byteLen.toString(16).padStart(4, '0').toUpperCase(); // 2 bytes = 4 hex chars
  
  // Data Padding
  const paddedDataBits = [...dataBits];
  while (paddedDataBits.length < byteLen * 8) {
    paddedDataBits.push(0);
  }
  const dataHex = bitsToHex(paddedDataBits);

  // CRC Calculation
  // Need to construct the payload for CRC
  // DestMAC + SrcMAC + Length + Data
  const lenBits = [];
  for (let j = 15; j >= 0; j--) lenBits.push((byteLen >> j) & 1);
  
  const payloadForCRC = [
    ...hexToBits(dest), 
    ...hexToBits(src), 
    ...lenBits, 
    ...paddedDataBits
  ];
  const crcBits = calculateCRC(payloadForCRC);
  const crcHex = bitsToHex(crcBits);

  return [
    { name: '前导码 (7B)', value: 'AA AA AA AA AA AA AA', color: COLORS.PREAMBLE, desc: '同步时钟' },
    { name: 'SFD (1B)', value: 'AB', color: COLORS.SFD, desc: '帧开始' },
    { name: '目的MAC (6B)', value: dest, color: COLORS.DEST_MAC, desc: '接收方地址' },
    { name: '源MAC (6B)', value: src, color: COLORS.SRC_MAC, desc: '发送方地址' },
    { name: '长度 (2B)', value: lenHex.match(/.{1,2}/g)?.join(' ') || '00 00', color: COLORS.LENGTH, desc: '数据长度' },
    { name: `数据 (${byteLen}B)`, value: dataHex || 'Empty', color: COLORS.DATA, desc: '有效载荷' },
    { name: 'CRC (4B)', value: crcHex, color: COLORS.CRC, desc: '差错校验' },
  ];
});

const machines = reactive<Record<string, Machine>>({
  A: createMachine('A', 'AA:AA:AA:AA:AA:AA'),
  B: createMachine('B', 'BB:BB:BB:BB:BB:BB'),
  C: createMachine('C', 'CC:CC:CC:CC:CC:CC'),
});

let animationId: number;
let tickCount = 0;

// --- 辅助函数 ---
function createMachine(id: string, mac: string): Machine {
  return {
    id,
    mac,
    state: 'IDLE',
    buffer: [],
    bitIndex: 0,
    backoffTimer: 0,
    currentOutput: 1,
    rxBuffer: [],
    rxState: 'SEARCHING',
    rxBitCount: 0,
    parsedDestMac: '',
    parsedSrcMac: '',
    parsedLength: 0,
  };
}

function getStatusClass(state: MachineState) {
  switch (state) {
    case 'SENDING': return 'status-sending';
    case 'RECEIVING': return 'status-receiving';
    case 'BACKOFF': return 'status-backoff';
    default: return 'status-idle';
  }
}

function log(msg: string) {
  const time = new Date().toLocaleTimeString();
  logs.value.push(`[${time}] ${msg}`);
  if (logs.value.length > 100) logs.value.shift();
  setTimeout(() => {
    if (logWindow.value) logWindow.value.scrollTop = logWindow.value.scrollHeight;
  }, 0);
}

function hexToBits(hex: string): number[] {
  const cleanHex = hex.replace(/[^0-9A-Fa-f]/g, '');
  const bits: number[] = [];
  for (let i = 0; i < cleanHex.length; i += 2) {
    const byte = parseInt(cleanHex.substr(i, 2), 16);
    for (let j = 7; j >= 0; j--) {
      bits.push((byte >> j) & 1);
    }
  }
  return bits;
}

function binStringToBits(bin: string): number[] {
  return bin.split('').map(c => c === '1' ? 1 : 0);
}

function bitsToHex(bits: number[]): string {
  let hex = '';
  for (let i = 0; i < bits.length; i += 8) {
    let byte = 0;
    for (let j = 0; j < 8; j++) {
      if (i + j < bits.length) {
        byte = (byte << 1) | bits[i + j];
      }
    }
    hex += byte.toString(16).padStart(2, '0').toUpperCase();
    if (i + 8 < bits.length) hex += ':';
  }
  return hex;
}

function calculateCRC(bits: number[]): number[] {
  let crc = 0xFFFFFFFF;
  for (let i = 0; i < bits.length; i++) {
    const bit = bits[i];
    let c = (crc >>> 31) & 1;
    crc = (crc << 1) ^ ((c ^ bit) ? 0x04C11DB7 : 0);
  }
  const res: number[] = [];
  for (let i = 31; i >= 0; i--) {
    res.push((crc >>> i) & 1);
  }
  return res;
}

// 构建帧
function buildFrame(destMac: string, srcMac: string, dataBits: number[]): number[] {
  const frame: number[] = [];
  
  // 1. 前导码 (7 bytes)
  for (let i = 0; i < PREAMBLE_LEN; i++) {
    for (let j = 7; j >= 0; j--) frame.push((PREAMBLE_BYTE >> j) & 1);
  }
  
  // 2. 帧开始定界符 (1 byte)
  for (let j = 7; j >= 0; j--) frame.push((SFD_BYTE >> j) & 1);
  
  // 3. 目的MAC
  frame.push(...hexToBits(destMac));
  
  // 4. 源MAC
  frame.push(...hexToBits(srcMac));
  
  // 5. 长度 (2 bytes)
  // 计算字节长度，向上取整
  const byteLen = Math.ceil(dataBits.length / 8);
  // 补齐数据位到字节边界
  const paddedDataBits = [...dataBits];
  while (paddedDataBits.length < byteLen * 8) {
    paddedDataBits.push(0);
  }
  
  const lenBits: number[] = [];
  for (let j = 15; j >= 0; j--) {
    lenBits.push((byteLen >> j) & 1);
  }
  frame.push(...lenBits);
  
  // 6. 数据
  frame.push(...paddedDataBits);
  
  // 7. CRC (计算范围：目的MAC + 源MAC + 长度 + 数据)
  const payloadForCRC = [
    ...hexToBits(destMac), 
    ...hexToBits(srcMac), 
    ...lenBits, 
    ...paddedDataBits
  ];
  const crcBits = calculateCRC(payloadForCRC);
  frame.push(...crcBits);
  
  return frame;
}

// --- 核心逻辑 ---

function startSending() {
  const m = machines[sender.value];
  if (m.state !== 'IDLE') return;

  const dataBits = binStringToBits(dataInput.value);
  const frame = buildFrame(targetMac.value, m.mac, dataBits);
  
  m.buffer = frame;
  m.bitIndex = 0;
  m.state = 'WAITING_BUS';
  log(`${m.id} 准备发送数据 (长度: ${Math.ceil(dataBits.length/8)} 字节)，正在监听信道...`);
}

function updateMachine(m: Machine) {
  // --- 发送逻辑 ---
  if (m.state === 'WAITING_BUS') {
    const last3 = busHistory.value.slice(-3);
    const isIdle = last3.every(v => v === 1);
    
    if (isIdle) {
      m.state = 'SENDING';
      log(`${m.id} 检测到信道空闲，开始发送...`);
    } else {
      m.backoffTimer = Math.floor(Math.random() * 50) + 10;
      m.state = 'BACKOFF';
      log(`${m.id} 信道忙，随机退避 ${m.backoffTimer} 周期`);
    }
  } else if (m.state === 'BACKOFF') {
    m.backoffTimer--;
    if (m.backoffTimer <= 0) {
      m.state = 'WAITING_BUS';
    }
  } else if (m.state === 'SENDING') {
    if (m.bitIndex < m.buffer.length) {
      m.currentOutput = m.buffer[m.bitIndex];
      m.bitIndex++;
    } else {
      m.state = 'IDLE';
      m.currentOutput = 1;
      log(`${m.id} 发送完毕`);
    }
  } else {
    m.currentOutput = 1;
  }

  // --- 接收逻辑 ---
  // 只有在 IDLE 或 RECEIVING 状态下才进行接收处理
  // 避免发送方接收自己发送的数据 (简化处理)
  if (m.state === 'IDLE' || m.state === 'RECEIVING') {
    const currentBit = busLevel.value;
    
    if (m.rxState === 'SEARCHING') {
      m.rxBuffer.push(currentBit);
      if (m.rxBuffer.length > 8) m.rxBuffer.shift();
      
      // 检查 SFD (10101011)
      const sfdBits = [1,0,1,0,1,0,1,1];
      let match = false;
      if (m.rxBuffer.length === 8) {
        match = m.rxBuffer.every((b, i) => b === sfdBits[i]);
      }
      
      if (match) {
        m.state = 'RECEIVING';
        m.rxState = 'READING_HEADER';
        m.rxBuffer = [];
        m.rxBitCount = 0;
        log(`${m.id} 检测到帧开始定界符 (SFD)，开始接收...`);
      }
    } else if (m.rxState === 'READING_HEADER') {
      m.rxBuffer.push(currentBit);
      m.rxBitCount++;
      
      // Header 结构: DestMAC(6) + SrcMAC(6) + Length(2) = 14 bytes = 112 bits
      
      // 1. 检查 DestMAC (前48位)
      if (m.rxBitCount === 48) {
        const destMacBits = m.rxBuffer.slice(0, 48);
        const destMacStr = bitsToHex(destMacBits);
        
        if (destMacStr === m.mac) {
           log(`${m.id} 目标MAC匹配 (${destMacStr})，继续接收...`);
        } else {
           log(`${m.id} 目标MAC不匹配 (${destMacStr})，丢弃帧。`);
           m.state = 'IDLE';
           m.rxState = 'SEARCHING';
           m.rxBuffer = [];
        }
      }
      
      // 2. 解析 Length (第112位时)
      if (m.rxBitCount === 112 && m.state === 'RECEIVING') {
         // SrcMAC 是 48-96位
         const srcMacBits = m.rxBuffer.slice(48, 96);
         m.parsedSrcMac = bitsToHex(srcMacBits);
         
         // Length 是 96-112位
         const lenBits = m.rxBuffer.slice(96, 112);
         let lenVal = 0;
         for(const b of lenBits) lenVal = (lenVal << 1) | b;
         m.parsedLength = lenVal;
         
         log(`${m.id} 解析到源MAC: ${m.parsedSrcMac}, 数据长度: ${lenVal} 字节`);
         
         m.rxState = 'READING_DATA';
         // 注意：rxBuffer 继续积累，不清空，以便最后做整体 CRC 校验
      }
      
    } else if (m.rxState === 'READING_DATA') {
      m.rxBuffer.push(currentBit);
      m.rxBitCount++;
      
      // Header(112) + Data(parsedLength * 8)
      const expectedBitsAtEndOfData = 112 + m.parsedLength * 8;
      
      if (m.rxBitCount === expectedBitsAtEndOfData) {
        m.rxState = 'READING_CRC';
      }
      
    } else if (m.rxState === 'READING_CRC') {
      m.rxBuffer.push(currentBit);
      m.rxBitCount++;
      
      // Header(112) + Data + CRC(32)
      const totalBits = 112 + m.parsedLength * 8 + 32;
      
      if (m.rxBitCount === totalBits) {
        // 接收完成，进行校验
        const fullFrame = m.rxBuffer;
        const crcReceived = fullFrame.slice(-32);
        const payloadForCRC = fullFrame.slice(0, -32); // DestMAC + SrcMAC + Length + Data
        
        const crcCalculated = calculateCRC(payloadForCRC);
        const crcOk = crcReceived.every((b, i) => b === crcCalculated[i]);
        
        // 提取数据
        const dataBits = payloadForCRC.slice(112); // Skip Header
        const dataBin = dataBits.join('');
        
        log(`${m.id} 接收完毕。CRC: ${crcOk ? '通过' : '失败'}`);
        if (crcOk) {
          log(`${m.id} 收到数据 (Bin): ${dataBin}`);
        }
        
        // 重置状态
        m.state = 'IDLE';
        m.rxState = 'SEARCHING';
        m.rxBuffer = [];
        m.rxBitCount = 0;
      }
    }
  }
}

function tick() {
  tickCount++;
  
  // 1. 确定总线状态
  let level = 1;
  if (machines.A.currentOutput === 0) level = 0;
  if (machines.B.currentOutput === 0) level = 0;
  if (machines.C.currentOutput === 0) level = 0;
  
  busLevel.value = level;
  busHistory.value.push(level);
  if (busHistory.value.length > 200) busHistory.value.shift();
  
  // 2. 更新机器状态
  updateMachine(machines.A);
  updateMachine(machines.B);
  updateMachine(machines.C);
  
  // 3. 绘图
  draw();
}

function draw() {
  if (!canvas.value) return;
  const ctx = canvas.value.getContext('2d');
  if (!ctx) return;
  
  const w = canvas.value.width;
  const h = canvas.value.height;
  
  ctx.clearRect(0, 0, w, h);
  
  // 绘制总线
  const busY = h / 2;
  ctx.beginPath();
  ctx.moveTo(50, busY);
  ctx.lineTo(w - 50, busY);
  ctx.lineWidth = 4;
  ctx.strokeStyle = busLevel.value === 1 ? '#4CAF50' : '#F44336';
  ctx.stroke();
  
  // 绘制机器连接线
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#333';
  
  // Machine A
  ctx.beginPath(); ctx.moveTo(100, 50); ctx.lineTo(100, busY); ctx.stroke();
  drawMachine(ctx, 100, 50, 'A', machines.A);
  
  // Machine B
  ctx.beginPath(); ctx.moveTo(350, 50); ctx.lineTo(350, busY); ctx.stroke();
  drawMachine(ctx, 350, 50, 'B', machines.B);
  
  // Machine C
  ctx.beginPath(); ctx.moveTo(600, 50); ctx.lineTo(600, busY); ctx.stroke();
  drawMachine(ctx, 600, 50, 'C', machines.C);
  
  // 绘制示波器
  const graphH = 50;
  const graphY = h - graphH - 10;
  ctx.fillStyle = '#000';
  ctx.fillRect(50, graphY, w - 100, graphH);
  
  ctx.beginPath();
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1;
  const historyLen = busHistory.value.length;
  const step = (w - 100) / 200;
  
  for (let i = 0; i < historyLen; i++) {
    const val = busHistory.value[historyLen - 1 - i];
    const x = (w - 50) - i * step;
    if (x < 50) break;
    const y = graphY + graphH - (val * (graphH - 10)) - 5;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function drawMachine(ctx: CanvasRenderingContext2D, x: number, y: number, label: string, m: Machine) {
  ctx.fillStyle = '#ddd';
  if (m.state === 'SENDING') ctx.fillStyle = '#FFEB3B';
  if (m.state === 'RECEIVING') ctx.fillStyle = '#2196F3';
  if (m.state === 'BACKOFF') ctx.fillStyle = '#FF9800';
  
  ctx.fillRect(x - 30, y - 30, 60, 60);
  ctx.strokeRect(x - 30, y - 30, 60, 60);
  
  ctx.fillStyle = '#000';
  ctx.font = '20px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x, y);
  
  ctx.font = '12px Arial';
  ctx.fillText(m.state, x, y + 45);
}

onMounted(() => {
  let lastTime = 0;
  const updateInterval = 50;
  
  const loop = (time: number) => {
    if (time - lastTime > updateInterval) {
      tick();
      lastTime = time;
    }
    draw();
    animationId = requestAnimationFrame(loop);
  };
  animationId = requestAnimationFrame(loop);
});

onUnmounted(() => {
  cancelAnimationFrame(animationId);
});
</script>

<style scoped>
.container {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
  background: #f5f5f5;
  border-radius: 8px;
}

.controls {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  background: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.control-group {
  flex: 1;
}

.control-group h3 {
  margin-top: 0;
  border-bottom: 2px solid #eee;
  padding-bottom: 10px;
}

.machine-status {
  margin-bottom: 5px;
  font-size: 14px;
}

.status-idle { color: #666; }
.status-sending { color: #FF9800; font-weight: bold; }
.status-receiving { color: #2196F3; font-weight: bold; }
.status-backoff { color: #F44336; font-weight: bold; }

label {
  display: block;
  margin-bottom: 10px;
  font-weight: bold;
}

input, select {
  width: 100%;
  padding: 8px;
  margin-top: 4px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  background: #4CAF50;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  width: 100%;
}

button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.visualization {
  background: white;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  display: flex;
  justify-content: center;
}

canvas {
  border: 1px solid #eee;
}

.logs {
  background: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.log-window {
  height: 150px;
  overflow-y: auto;
  background: #333;
  color: #0f0;
  padding: 10px;
  font-family: 'Consolas', monospace;
  font-size: 12px;
  border-radius: 4px;
}

.log-entry {
  margin-bottom: 4px;
  border-bottom: 1px solid #444;
  padding-bottom: 2px;
}

.frame-preview-container {
  background: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  overflow-x: auto;
}

.frame-preview {
  display: flex;
  gap: 2px;
  margin-bottom: 10px;
  min-width: max-content;
}

.frame-field {
  padding: 8px;
  border: 1px solid #ccc;
  text-align: center;
  min-width: 60px;
}

.field-name {
  font-weight: bold;
  font-size: 12px;
  margin-bottom: 4px;
  color: #333;
}

.field-value {
  font-family: 'Consolas', monospace;
  font-size: 12px;
  word-break: break-all;
}

.legend {
  display: flex;
  gap: 15px;
  font-size: 12px;
  flex-wrap: wrap;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
}

.color-box {
  width: 12px;
  height: 12px;
  border: 1px solid #999;
}
</style>
