---
date: 2026-01-11
category:
  - 机器学习
title: 亚博机械臂
---

## 介绍
这是一个机械臂，买了后要自己拼。然后，它有一个主机和一个机械臂本体，会通过一块铁板连在一起，主机是jetson nano，机械臂本体是通过usb线连接到主机上。
<img src="https://ansy.online/robotic-arm.jpg" alt="亚博机械臂" style="max-height: 700px; width: auto;" />

## 连接
机械臂通过usb线连接到主机上，主机通过网线连接到路由器上。机械臂的连线如下图所示：<br>
（主机的电源线我标错了，这里是HDMI线，电源线是下面那个圆形的孔的线）
<img src="https://ansy.online/机械臂的连线.png" alt="亚博机械臂" style="height: 400px; width: auto;" />
里面会有一个手柄，如果要用手柄操控的话。直接把手柄包里面得那个无线USB插到主机里面就行了。

## 基础使用

首先，要给这个小主机连接显示屏还有鼠标键盘，让它和你要操控你的电脑，连同一个局域网。

然后，打开终端，输入ip addr命令，找到你的主机的ip地址

最后，直接ssh连接或者在游览器输入ip:8888 就可以进入jupyter notebook页面了。

进入之后，会让你输密码，一般是yahboom

接下来，你就可以在notebook里面编程操控机械臂了。

### 示例代码
如图所示，你需要先打开这个地方，这里面存了了很多关于机械臂还有AI的资料。
<img src="https://ansy.online/compressed_亚博机械臂jupyter.png" alt="亚博机械臂" style="height: 350px; width: auto;" />

### 连接机械臂
先用这条命令查看机械臂连接的端口
```shell
ls /dev/ttyUSB*  2>/dev/null || true  #输出：/dev/ttyUSB1
```

然后，使用pytohn
```python
# 导入库  import library
import os
import ipywidgets.widgets as widgets
from IPython.display import display
import time
import threading
from pymycobot.mycobot import MyCobot
from pymycobot.genre import Angle
mc = MyCobot('/dev/ttyUSB1', 1000000) # 注意，这里要填你刚才输出的端口
g_speed = 50 # 机械臂运动速度
```

这样，我们就获得了一个连接机械臂的实例。

### 控制机械臂关节
这个实列可以通过改变不同关节的角度来控制机械臂的姿态。<br>
比如：
```python
mc.send_angles([0, 0, 0, 0, 0, -45], 50)  # 机械臂回到初始位置
```
解析：mc.send_angles(列表, 速度)<br>
列表里面的6个数字，分别代表机械臂6个关节的角度，速度是机械臂运动的速度。

### 控制夹爪

`mc.set_gripper_value(value, speed)` 是 pymycobot 库中控制夹爪开合的函数。

- `value`: 夹爪开合程度 (0-100)，0=完全闭合，100=完全张开
- `speed`: 运动速度 (0-100)

例如：

```python
mc.set_gripper_value(100, 50)  # 完全张开夹爪，速度50
```


## 自动跟踪面部

### 实现思路说明
本项目的自动跟踪实现思路如下：
1. 通过YOLO模型识别面部，获取面部中心坐标。
2. 以摄像头画面的中心作为原点，检测到的人脸中心作为目标点，做一条向量。
3. 将该向量分解为X和Y方向的长度。
4. 编写函数（set_arm_angles_by_xy）将X、Y方向的偏移量转换为机械臂关节的旋转角度。
5. 机械臂根据计算出的角度自动调整自身姿态，实现对面部的持续跟踪。
这种方式可以让机械臂始终对准画面中的人脸，实现动态追踪。

以下是基于YOLO面部检测模型的完整实现示例。

### 所需库
首先，需要安装必要的库：
```shell
pip install ultralytics opencv-python pymycobot ipywidgets
```

### 导入库和初始化
```python
import cv2 as cv
import threading
from time import sleep
import ipywidgets as widgets
from IPython.display import display
from ultralytics import YOLO
from pymycobot.mycobot import MyCobot

# 初始化YOLO面部检测模型
model_yolo = YOLO('yolov8n-face.pt')

# 初始化机械臂
mc = MyCobot('/dev/ttyUSB0', 1000000)  # 根据实际端口调整
mc.set_fresh_mode(1)  # 开启刷新模式，减少延迟
g_speed = 40  # 机械臂运动速度

# 当前角度变量
current_x_angle = 0  # 左右角度
current_y_angle = 0  # 上下角度
```

### 辅助函数
```python
def get_detection_center(results, idx=0):
    """
    获取检测框中心点坐标
    """
    boxes = results[0].boxes
    if boxes is None or len(boxes) == 0:
        return None
    xyxy = boxes.xyxy.cpu().numpy()
    if idx >= len(xyxy):
        return None
    x1, y1, x2, y2 = xyxy[idx]
    cx = int((x1 + x2) / 2)
    cy = int((y1 + y2) / 2)
    return (cx, cy)

def get_vector_from_center(cx, cy, img_width=640, img_height=480):
    """
    计算从屏幕中心到目标点的向量
    """
    center_x = img_width // 2
    center_y = img_height // 2
    dx = cx - center_x
    dy = cy - center_y
    return dx, dy

def set_arm_angles_by_xy(x_angle, y_angle, speed=50):
    """
    根据x、y角度设置机械臂关节
    """
    angles = [x_angle, y_angle, y_angle, y_angle, x_angle, 45]
    mc.send_angles(angles, speed)

def detect_best_target(img, model):
    """
    执行YOLO检测并寻找离中心最近的目标
    """
    results = model(img, verbose=False)
    target_center = None
    min_dist = float('inf')
    
    if results[0].boxes is not None:
        for i, box in enumerate(results[0].boxes):
            temp_center = get_detection_center(results, idx=i)
            if temp_center:
                t_dx, t_dy = get_vector_from_center(*temp_center)
                dist = t_dx**2 + t_dy**2
                if dist < min_dist:
                    min_dist = dist
                    target_center = temp_center
    
    return target_center, results[0].plot()
```

### 摄像头循环和控制逻辑
```python
import time

# 全局变量
latest_frame = None
camera_running = False
capture = cv.VideoCapture(0)

# 浮点数角度用于平滑控制
current_x_angle_float = 0.0
current_y_angle_float = 0.0

def camera_loop():
    """持续运行的摄像头循环"""
    global latest_frame, camera_running, capture
    global current_x_angle_float, current_y_angle_float, current_x_angle, current_y_angle
    
    # 同步初始角度
    current_x_angle_float = float(current_x_angle)
    current_y_angle_float = float(current_y_angle)

    if not capture.isOpened():
        capture = cv.VideoCapture(0)
        sleep(0.3)
    
    camera_running = True
    print("摄像头已启动，持续运行中...")
    
    last_send_time = 0
    control_interval = 0.000
    
    # 控制参数
    dead_zone = 15
    gain_x = 0.004
    gain_y = 0.003
    
    # 追踪惯性
    last_dx, last_dy = 0, 0
    lost_count = 0
    
    while camera_running:
        try:
            ret, img = capture.read()
            if not ret or img is None:
                print("无法读取摄像头")
                break
            
            img = cv.resize(img, (640, 480))
            
            # 检测逻辑
            target_center, annotated_frame = detect_best_target(img, model_yolo)
            latest_frame = img
            imgbox.value = cv.imencode('.jpg', annotated_frame)[1].tobytes()

            # 追踪逻辑
            dx, dy = 0, 0
            
            if target_center:
                dx, dy = get_vector_from_center(*target_center)
                last_dx, last_dy = dx, dy
                lost_count = 0
            else:
                lost_count += 1
                if lost_count < 20:
                    if abs(last_dx) > 150: dx = last_dx
                    if abs(last_dy) > 150: dy = last_dy

            # 执行控制
            need_move = False
            if abs(dx) > dead_zone:
                current_x_angle_float += -dx * gain_x
                current_x_angle_float = max(-90, min(90, current_x_angle_float))
                need_move = True
                
            if abs(dy) > dead_zone:
                current_y_angle_float += -dy * gain_y
                current_y_angle_float = max(-90, min(90, current_y_angle_float))
                need_move = True
            
            if need_move and (time.time() - last_send_time > control_interval):
                send_x, send_y = int(current_x_angle_float), int(current_y_angle_float)
                current_x_angle, current_y_angle = send_x, send_y
                set_arm_angles_by_xy(send_x, send_y, g_speed)
                last_send_time = time.time()
            
            sleep(0.005)
            
        except Exception as e:
            print(f"循环发生错误: {e}")
            continue

    print("摄像头已停止")

def stop_camera():
    """停止摄像头循环"""
    global camera_running
    camera_running = False
```

### 用户界面
```python
# 图像显示控件
imgbox = widgets.Image(format='jpg', height=480, width=640, layout=widgets.Layout(align_self='center'))

# 按钮
btn_start = widgets.Button(description='▶ 启动', button_style='success')
btn_stop = widgets.Button(description='⏹ 停止', button_style='danger')
output = widgets.Output()

def on_start_click(b):
    with output:
        camera_thread = threading.Thread(target=camera_loop, daemon=True)
        camera_thread.start()
        
def on_stop_click(b):
    with output:
        stop_camera()

btn_start.on_click(on_start_click)
btn_stop.on_click(on_stop_click)

# 显示界面
display(imgbox)
display(widgets.HBox([btn_start, btn_stop]))
display(output)
```

### 运行说明
1. 确保YOLO模型文件 `yolov8n-face.pt` 已下载
2. 运行上述代码后，点击"启动"按钮开始跟踪
3. 机械臂会自动调整角度跟踪检测到的面部
4. 点击"停止"按钮结束跟踪